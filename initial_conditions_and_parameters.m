%% nosie setting
noise_v = 0.0015; % gain for velocity noise
noise_a = 0.0005; % gain for angle noise
sample_a = 0.01; % noise sample time for angle
sample_v = 0.04; % noise sample time for velocity
delay_a = 0; % delay for angel mesasure
delay_v = 0.1; % delay for velocity mesasure
delay_limit = 0.3; % dynamic delay limit
delay_sample = 0.1; % dynamic delay sample time


% ===== Inner-loop controller switch =====
% 0: classic UDE-based control (use velocity feedback)
% 1: passivity-based control Type1 (no velocity measurement and no desired velocity used)
% 2: passivity-based control Type2 (no desired velocity used)
Inner_loop_controller_switch = 0;

% ===== Enable desired angular rate differentiator =====
% 1: enable    0: disable
% If enabled, the disired angular rate is numerically differentiated from 
% the desired angle generated by the outer-loop control. If disabled, 
% the desired angular rate is set to 0.
Enable_desired_angular_rate_differentiator = 0;
% generate random seed for noise 
rng('shuffle');
seed_vx = floor(rand()*10000000);
seed_vy = floor(rand()*10000000);
seed_vz = floor(rand()*10000000);
seed_phi = floor(rand()*10000000);
seed_theta = floor(rand()*10000000);
seed_psi = floor(rand()*10000000);
seed_delay_phi = floor(rand()*10000000);
seed_delay_theta = floor(rand()*10000000);
seed_delay_psi = floor(rand()*10000000);
seed_delay_vx = floor(rand()*10000000);
seed_delay_vy = floor(rand()*10000000);
seed_delay_vz = floor(rand()*10000000);

%% ===== controller gains =====
ang_max = 6*pi/180;
T_d_angle_rate = 0.5;
T_d_v = 0.5;
kp_phi = 250;
kd_phi = 70;
kp_theta = 250;
kd_theta = 70;
kp_psi = 250;
kd_psi = 70;
% Angle Rate
Kdphi_P = 1;
Kdphi_I = 0.68;
Kdphi_D = 0.03;
Kdtheta_P = 1;
Kdtheta_I = 0.68;
Kdtheta_D = 0.03;
Kdpsi_P = 1;
Kdpsi_I = 0.68;
Kdpsi_D = 0.03;

kp_x = 0;
kd_x = 1;
kp_y = 0;
kd_y = 1;
kp_z = 20;
kd_z = 1;

Kvx_P = 0.3;
Kvx_I = 0.1;
Kvx_D = 0.15;

Kvy_P = 0.3;
Kvy_I = 0.1;
Kvy_D = 0.15;

Kvz_P = 1;
Kvz_I = 0.1;
Kvz_D = 0;

%% ===== external disturbance forces and torques =====
f_g = [0 0 0];  % forces in ground-frame
ftau_b = [0 0 0];   % torques in body-frame
% f_g = [0 0 0];
% ftau_b = [0 0 0];

%% ===== quadrotor/environment parameters =====
Ix = 0.01;
Iy = 0.01;
Iz = 0.02;  % moment of inertia
Ir = 3.789e-6; % total moment of inertia of motor+rotor
CD = [0.018944 0.018944 0.018944];   % air drag coeffecients;
% CD = [0 0 0];  % no air drag applied
g = 9.8;  % standard acceleration due to gravity
m = 0.5; % total mass
LT = 0.1*sqrt(2); % sqrt(2)/2 * arm length
T_max = 30;  % maximum thrust generated by the controller
tau_x_max = 1;  % maximum torque generated by the controller
tau_y_max = 1;  % maximum torque generated by the controller
tau_z_max = 1;  % maximum torque generated by the controller
%% ESC
ESC_k = 718.078;
ESC_p = 88.448;

%% motors and propellers
hT = 1.239e-5;
hM = 1.982e-7;


%% ===== convert dynamics into second-order system description =====
% x1_dot = x2;
% x2_dot = a1*x1 + a2*x2 + w + u + f
a1_x = 0; 
a2_x = 0;  % x-channel, w_x=0; u_x = -cos(psi)*sin(theta)*cos(phi)*T/m;
a1_y = 0; 
a2_y = 0;  % y-channel, w_y=0; u_y = cos(psi)*sin(phi)*T/m;
a1_z = 0; 
a2_z = 0;  % h-channel, w_h=-g; u_h = cos(theta)*cos(phi)*T/m;

% ===== initial conditions =====
p_initial = 0;
q_initial = 0;
r_initial = 0;
u_initial = 0;
v_initial = 0;
w_initial = 0;
theta_initial = 0;
phi_initial = 0;
psi_initial = 0;
x_g_initial = 0;
y_g_initial = 0;
z_g_initial = 0;

%% SineSweep paremeters
peak = 1;
[t, data] = sinesweep(f0, f1, sweeptime, samplingrate, peak);

% SineSweep
function [tout, data] = sinesweep(f0, f1, sweeptime, samplingrate, peak)
% 扫频信号：起始频率f0、截止频率f1、采样率和幅度
k = exp(log(f1 / f0) / sweeptime); % 增长系数k的计算公式
data_len = sweeptime * samplingrate; % 数据长度
data = zeros(data_len,1);% 创建一个长度为数据长度的全为0的int类型数组，用以存储每个采样点的幅度值
dt = 1.0 / samplingrate; % 两个采样点的相隔时间
t = 0; % 起始时间
tout = zeros(data_len,1);
p = 2 * pi * f0 / log(k);
for i=1:data_len
    data(i) = peak * sin(p * (k^t - 1));% 将每个采样点的幅度值存入数组
    tout(i) = t;
    t = t+dt; % 每次加一个时间间隔
end
end